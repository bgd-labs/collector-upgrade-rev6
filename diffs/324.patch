diff --git a/flattened/324/0xF9C838BDec2fb25fa96f81c162A9B07f79056b8F.sol b/flattened/Collector.sol
index 41524db..ad36cab 100644
--- a/flattened/324/0xF9C838BDec2fb25fa96f81c162A9B07f79056b8F.sol
+++ b/flattened/Collector.sol
@@ -1,42 +1,482 @@
 // SPDX-License-Identifier: MIT
-pragma solidity ^0.8.0 ^0.8.10;
+pragma solidity ^0.8.0 ^0.8.20;
 
-// src/core/contracts/dependencies/openzeppelin/contracts/Address.sol
+// lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Errors.sol
 
-// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)
+// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)
+
+/**
+ * @dev Collection of common custom errors used in multiple contracts
+ *
+ * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.
+ * It is recommended to avoid relying on the error API for critical functionality.
+ *
+ * _Available since v5.1._
+ */
+library Errors {
+  /**
+   * @dev The ETH balance of the account is not enough to perform the operation.
+   */
+  error InsufficientBalance(uint256 balance, uint256 needed);
+
+  /**
+   * @dev A call to an address target failed. The target may have reverted.
+   */
+  error FailedCall();
+
+  /**
+   * @dev The deployment failed.
+   */
+  error FailedDeployment();
+
+  /**
+   * @dev A necessary precompile is missing.
+   */
+  error MissingPrecompile(address);
+}
+
+// lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol
+
+// OpenZeppelin Contracts (last updated v5.1.0) (access/IAccessControl.sol)
+
+/**
+ * @dev External interface of AccessControl declared to support ERC-165 detection.
+ */
+interface IAccessControl {
+  /**
+   * @dev The `account` is missing a role.
+   */
+  error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
+
+  /**
+   * @dev The caller of a function is not the expected one.
+   *
+   * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.
+   */
+  error AccessControlBadConfirmation();
+
+  /**
+   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
+   *
+   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
+   * {RoleAdminChanged} not being emitted signaling this.
+   */
+  event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
+
+  /**
+   * @dev Emitted when `account` is granted `role`.
+   *
+   * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).
+   * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.
+   */
+  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
+
+  /**
+   * @dev Emitted when `account` is revoked `role`.
+   *
+   * `sender` is the account that originated the contract call:
+   *   - if using `revokeRole`, it is the admin role bearer
+   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
+   */
+  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
+
+  /**
+   * @dev Returns `true` if `account` has been granted `role`.
+   */
+  function hasRole(bytes32 role, address account) external view returns (bool);
+
+  /**
+   * @dev Returns the admin role that controls `role`. See {grantRole} and
+   * {revokeRole}.
+   *
+   * To change a role's admin, use {AccessControl-_setRoleAdmin}.
+   */
+  function getRoleAdmin(bytes32 role) external view returns (bytes32);
+
+  /**
+   * @dev Grants `role` to `account`.
+   *
+   * If `account` had not been already granted `role`, emits a {RoleGranted}
+   * event.
+   *
+   * Requirements:
+   *
+   * - the caller must have ``role``'s admin role.
+   */
+  function grantRole(bytes32 role, address account) external;
+
+  /**
+   * @dev Revokes `role` from `account`.
+   *
+   * If `account` had been granted `role`, emits a {RoleRevoked} event.
+   *
+   * Requirements:
+   *
+   * - the caller must have ``role``'s admin role.
+   */
+  function revokeRole(bytes32 role, address account) external;
+
+  /**
+   * @dev Revokes `role` from the calling account.
+   *
+   * Roles are often managed via {grantRole} and {revokeRole}: this function's
+   * purpose is to provide a mechanism for accounts to lose their privileges
+   * if they are compromised (such as when a trusted device is misplaced).
+   *
+   * If the calling account had been granted `role`, emits a {RoleRevoked}
+   * event.
+   *
+   * Requirements:
+   *
+   * - the caller must be `callerConfirmation`.
+   */
+  function renounceRole(bytes32 role, address callerConfirmation) external;
+}
+
+// lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol
+
+// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)
+
+/**
+ * @dev Interface of the ERC-165 standard, as defined in the
+ * https://eips.ethereum.org/EIPS/eip-165[ERC].
+ *
+ * Implementers can declare support of contract interfaces, which can then be
+ * queried by others ({ERC165Checker}).
+ *
+ * For an implementation, see {ERC165}.
+ */
+interface IERC165 {
+  /**
+   * @dev Returns true if this contract implements the interface defined by
+   * `interfaceId`. See the corresponding
+   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]
+   * to learn more about how these ids are created.
+   *
+   * This function call must use less than 30 000 gas.
+   */
+  function supportsInterface(bytes4 interfaceId) external view returns (bool);
+}
+
+// lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
+
+// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)
+
+/**
+ * @dev Interface of the ERC-20 standard as defined in the ERC.
+ */
+interface IERC20 {
+  /**
+   * @dev Emitted when `value` tokens are moved from one account (`from`) to
+   * another (`to`).
+   *
+   * Note that `value` may be zero.
+   */
+  event Transfer(address indexed from, address indexed to, uint256 value);
+
+  /**
+   * @dev Emitted when the allowance of a `spender` for an `owner` is set by
+   * a call to {approve}. `value` is the new allowance.
+   */
+  event Approval(address indexed owner, address indexed spender, uint256 value);
+
+  /**
+   * @dev Returns the value of tokens in existence.
+   */
+  function totalSupply() external view returns (uint256);
+
+  /**
+   * @dev Returns the value of tokens owned by `account`.
+   */
+  function balanceOf(address account) external view returns (uint256);
+
+  /**
+   * @dev Moves a `value` amount of tokens from the caller's account to `to`.
+   *
+   * Returns a boolean value indicating whether the operation succeeded.
+   *
+   * Emits a {Transfer} event.
+   */
+  function transfer(address to, uint256 value) external returns (bool);
+
+  /**
+   * @dev Returns the remaining number of tokens that `spender` will be
+   * allowed to spend on behalf of `owner` through {transferFrom}. This is
+   * zero by default.
+   *
+   * This value changes when {approve} or {transferFrom} are called.
+   */
+  function allowance(address owner, address spender) external view returns (uint256);
+
+  /**
+   * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
+   * caller's tokens.
+   *
+   * Returns a boolean value indicating whether the operation succeeded.
+   *
+   * IMPORTANT: Beware that changing an allowance with this method brings the risk
+   * that someone may use both the old and the new allowance by unfortunate
+   * transaction ordering. One possible solution to mitigate this race
+   * condition is to first reduce the spender's allowance to 0 and set the
+   * desired value afterwards:
+   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
+   *
+   * Emits an {Approval} event.
+   */
+  function approve(address spender, uint256 value) external returns (bool);
+
+  /**
+   * @dev Moves a `value` amount of tokens from `from` to `to` using the
+   * allowance mechanism. `value` is then deducted from the caller's
+   * allowance.
+   *
+   * Returns a boolean value indicating whether the operation succeeded.
+   *
+   * Emits a {Transfer} event.
+   */
+  function transferFrom(address from, address to, uint256 value) external returns (bool);
+}
+
+// lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol
+
+// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)
+
+/**
+ * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
+ * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an
+ * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
+ * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
+ *
+ * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be
+ * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in
+ * case an upgrade adds a module that needs to be initialized.
+ *
+ * For example:
+ *
+ * [.hljs-theme-light.nopadding]
+ * ```solidity
+ * contract MyToken is ERC20Upgradeable {
+ *     function initialize() initializer public {
+ *         __ERC20_init("MyToken", "MTK");
+ *     }
+ * }
+ *
+ * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {
+ *     function initializeV2() reinitializer(2) public {
+ *         __ERC20Permit_init("MyToken");
+ *     }
+ * }
+ * ```
+ *
+ * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
+ * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
+ *
+ * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
+ * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
+ *
+ * [CAUTION]
+ * ====
+ * Avoid leaving a contract uninitialized.
+ *
+ * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation
+ * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke
+ * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:
+ *
+ * [.hljs-theme-light.nopadding]
+ * ```
+ * /// @custom:oz-upgrades-unsafe-allow constructor
+ * constructor() {
+ *     _disableInitializers();
+ * }
+ * ```
+ * ====
+ */
+abstract contract Initializable {
+  /**
+   * @dev Storage of the initializable contract.
+   *
+   * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions
+   * when using with upgradeable contracts.
+   *
+   * @custom:storage-location erc7201:openzeppelin.storage.Initializable
+   */
+  struct InitializableStorage {
+    /**
+     * @dev Indicates that the contract has been initialized.
+     */
+    uint64 _initialized;
+    /**
+     * @dev Indicates that the contract is in the process of being initialized.
+     */
+    bool _initializing;
+  }
+
+  // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))
+  bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;
+
+  /**
+   * @dev The contract is already initialized.
+   */
+  error InvalidInitialization();
+
+  /**
+   * @dev The contract is not initializing.
+   */
+  error NotInitializing();
+
+  /**
+   * @dev Triggered when the contract has been initialized or reinitialized.
+   */
+  event Initialized(uint64 version);
+
+  /**
+   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,
+   * `onlyInitializing` functions can be used to initialize parent contracts.
+   *
+   * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any
+   * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in
+   * production.
+   *
+   * Emits an {Initialized} event.
+   */
+  modifier initializer() {
+    // solhint-disable-next-line var-name-mixedcase
+    InitializableStorage storage $ = _getInitializableStorage();
+
+    // Cache values to avoid duplicated sloads
+    bool isTopLevelCall = !$._initializing;
+    uint64 initialized = $._initialized;
+
+    // Allowed calls:
+    // - initialSetup: the contract is not in the initializing state and no previous version was
+    //                 initialized
+    // - construction: the contract is initialized at version 1 (no reininitialization) and the
+    //                 current contract is just being deployed
+    bool initialSetup = initialized == 0 && isTopLevelCall;
+    bool construction = initialized == 1 && address(this).code.length == 0;
+
+    if (!initialSetup && !construction) {
+      revert InvalidInitialization();
+    }
+    $._initialized = 1;
+    if (isTopLevelCall) {
+      $._initializing = true;
+    }
+    _;
+    if (isTopLevelCall) {
+      $._initializing = false;
+      emit Initialized(1);
+    }
+  }
+
+  /**
+   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the
+   * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be
+   * used to initialize parent contracts.
+   *
+   * A reinitializer may be used after the original initialization step. This is essential to configure modules that
+   * are added through upgrades and that require initialization.
+   *
+   * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`
+   * cannot be nested. If one is invoked in the context of another, execution will revert.
+   *
+   * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in
+   * a contract, executing them in the right order is up to the developer or operator.
+   *
+   * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.
+   *
+   * Emits an {Initialized} event.
+   */
+  modifier reinitializer(uint64 version) {
+    // solhint-disable-next-line var-name-mixedcase
+    InitializableStorage storage $ = _getInitializableStorage();
+
+    if ($._initializing || $._initialized >= version) {
+      revert InvalidInitialization();
+    }
+    $._initialized = version;
+    $._initializing = true;
+    _;
+    $._initializing = false;
+    emit Initialized(version);
+  }
+
+  /**
+   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the
+   * {initializer} and {reinitializer} modifiers, directly or indirectly.
+   */
+  modifier onlyInitializing() {
+    _checkInitializing();
+    _;
+  }
+
+  /**
+   * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.
+   */
+  function _checkInitializing() internal view virtual {
+    if (!_isInitializing()) {
+      revert NotInitializing();
+    }
+  }
+
+  /**
+   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.
+   * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized
+   * to any version. It is recommended to use this to lock implementation contracts that are designed to be called
+   * through proxies.
+   *
+   * Emits an {Initialized} event the first time it is successfully executed.
+   */
+  function _disableInitializers() internal virtual {
+    // solhint-disable-next-line var-name-mixedcase
+    InitializableStorage storage $ = _getInitializableStorage();
+
+    if ($._initializing) {
+      revert InvalidInitialization();
+    }
+    if ($._initialized != type(uint64).max) {
+      $._initialized = type(uint64).max;
+      emit Initialized(type(uint64).max);
+    }
+  }
+
+  /**
+   * @dev Returns the highest version that has been initialized. See {reinitializer}.
+   */
+  function _getInitializedVersion() internal view returns (uint64) {
+    return _getInitializableStorage()._initialized;
+  }
+
+  /**
+   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.
+   */
+  function _isInitializing() internal view returns (bool) {
+    return _getInitializableStorage()._initializing;
+  }
+
+  /**
+   * @dev Returns a pointer to the storage namespace.
+   */
+  // solhint-disable-next-line var-name-mixedcase
+  function _getInitializableStorage() private pure returns (InitializableStorage storage $) {
+    assembly {
+      $.slot := INITIALIZABLE_STORAGE
+    }
+  }
+}
+
+// lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Address.sol
+
+// OpenZeppelin Contracts (last updated v5.1.0) (utils/Address.sol)
 
 /**
  * @dev Collection of functions related to the address type
  */
 library Address {
   /**
-   * @dev Returns true if `account` is a contract.
-   *
-   * [IMPORTANT]
-   * ====
-   * It is unsafe to assume that an address for which this function returns
-   * false is an externally-owned account (EOA) and not a contract.
-   *
-   * Among others, `isContract` will return false for the following
-   * types of addresses:
-   *
-   *  - an externally-owned account
-   *  - a contract in construction
-   *  - an address where a contract will be created
-   *  - an address where a contract lived, but was destroyed
-   * ====
+   * @dev There's no code at `target` (it is not a contract).
    */
-  function isContract(address account) internal view returns (bool) {
-    // This method relies on extcodesize, which returns 0 for contracts in
-    // construction, since the code is only stored at the end of the
-    // constructor execution.
-
-    uint256 size;
-    assembly {
-      size := extcodesize(account)
-    }
-    return size > 0;
-  }
+  error AddressEmptyCode(address target);
 
   /**
    * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
@@ -47,18 +487,22 @@ library Address {
    * imposed by `transfer`, making them unable to receive funds via
    * `transfer`. {sendValue} removes this limitation.
    *
-   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
+   * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
    *
    * IMPORTANT: because control is transferred to `recipient`, care must be
    * taken to not create reentrancy vulnerabilities. Consider using
    * {ReentrancyGuard} or the
-   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
+   * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
    */
   function sendValue(address payable recipient, uint256 amount) internal {
-    require(address(this).balance >= amount, 'Address: insufficient balance');
+    if (address(this).balance < amount) {
+      revert Errors.InsufficientBalance(address(this).balance, amount);
+    }
 
-    (bool success, ) = recipient.call{value: amount}('');
-    require(success, 'Address: unable to send value, recipient may have reverted');
+    (bool success,) = recipient.call{value: amount}('');
+    if (!success) {
+      revert Errors.FailedCall();
+    }
   }
 
   /**
@@ -66,8 +510,10 @@ library Address {
    * plain `call` is an unsafe replacement for a function call: use this
    * function instead.
    *
-   * If `target` reverts with a revert reason, it is bubbled up by this
-   * function (like regular Solidity function calls).
+   * If `target` reverts with a revert reason or custom error, it is bubbled
+   * up by this function (like regular Solidity function calls). However, if
+   * the call reverted with no returned reason, this function reverts with a
+   * {Errors.FailedCall} error.
    *
    * Returns the raw returned data. To convert to the expected return value,
    * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
@@ -76,25 +522,9 @@ library Address {
    *
    * - `target` must be a contract.
    * - calling `target` with `data` must not revert.
-   *
-   * _Available since v3.1._
    */
   function functionCall(address target, bytes memory data) internal returns (bytes memory) {
-    return functionCall(target, data, 'Address: low-level call failed');
-  }
-
-  /**
-   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
-   * `errorMessage` as a fallback revert reason when `target` reverts.
-   *
-   * _Available since v3.1._
-   */
-  function functionCall(
-    address target,
-    bytes memory data,
-    string memory errorMessage
-  ) internal returns (bytes memory) {
-    return functionCallWithValue(target, data, 0, errorMessage);
+    return functionCallWithValue(target, data, 0);
   }
 
   /**
@@ -105,346 +535,117 @@ library Address {
    *
    * - the calling contract must have an ETH balance of at least `value`.
    * - the called Solidity function must be `payable`.
-   *
-   * _Available since v3.1._
    */
-  function functionCallWithValue(
-    address target,
-    bytes memory data,
-    uint256 value
-  ) internal returns (bytes memory) {
-    return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');
-  }
-
-  /**
-   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
-   * with `errorMessage` as a fallback revert reason when `target` reverts.
-   *
-   * _Available since v3.1._
-   */
-  function functionCallWithValue(
-    address target,
-    bytes memory data,
-    uint256 value,
-    string memory errorMessage
-  ) internal returns (bytes memory) {
-    require(address(this).balance >= value, 'Address: insufficient balance for call');
-    require(isContract(target), 'Address: call to non-contract');
-
+  function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
+    if (address(this).balance < value) {
+      revert Errors.InsufficientBalance(address(this).balance, value);
+    }
     (bool success, bytes memory returndata) = target.call{value: value}(data);
-    return verifyCallResult(success, returndata, errorMessage);
+    return verifyCallResultFromTarget(target, success, returndata);
   }
 
   /**
    * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
    * but performing a static call.
-   *
-   * _Available since v3.3._
    */
-  function functionStaticCall(
-    address target,
-    bytes memory data
-  ) internal view returns (bytes memory) {
-    return functionStaticCall(target, data, 'Address: low-level static call failed');
-  }
-
-  /**
-   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
-   * but performing a static call.
-   *
-   * _Available since v3.3._
-   */
-  function functionStaticCall(
-    address target,
-    bytes memory data,
-    string memory errorMessage
-  ) internal view returns (bytes memory) {
-    require(isContract(target), 'Address: static call to non-contract');
-
+  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
     (bool success, bytes memory returndata) = target.staticcall(data);
-    return verifyCallResult(success, returndata, errorMessage);
+    return verifyCallResultFromTarget(target, success, returndata);
   }
 
   /**
    * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
    * but performing a delegate call.
-   *
-   * _Available since v3.4._
    */
   function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
-    return functionDelegateCall(target, data, 'Address: low-level delegate call failed');
-  }
-
-  /**
-   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
-   * but performing a delegate call.
-   *
-   * _Available since v3.4._
-   */
-  function functionDelegateCall(
-    address target,
-    bytes memory data,
-    string memory errorMessage
-  ) internal returns (bytes memory) {
-    require(isContract(target), 'Address: delegate call to non-contract');
-
     (bool success, bytes memory returndata) = target.delegatecall(data);
-    return verifyCallResult(success, returndata, errorMessage);
+    return verifyCallResultFromTarget(target, success, returndata);
   }
 
   /**
-   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
-   * revert reason using the provided one.
-   *
-   * _Available since v4.3._
+   * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target
+   * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case
+   * of an unsuccessful call.
    */
-  function verifyCallResult(
-    bool success,
-    bytes memory returndata,
-    string memory errorMessage
-  ) internal pure returns (bytes memory) {
-    if (success) {
-      return returndata;
+  function verifyCallResultFromTarget(address target, bool success, bytes memory returndata)
+    internal
+    view
+    returns (bytes memory)
+  {
+    if (!success) {
+      _revert(returndata);
     } else {
-      // Look for revert reason and bubble it up if present
-      if (returndata.length > 0) {
-        // The easiest way to bubble the revert reason is using memory via assembly
-
-        assembly {
-          let returndata_size := mload(returndata)
-          revert(add(32, returndata), returndata_size)
-        }
-      } else {
-        revert(errorMessage);
+      // only check if target is a contract if the call was successful and the return data is empty
+      // otherwise we already know that it was a contract
+      if (returndata.length == 0 && target.code.length == 0) {
+        revert AddressEmptyCode(target);
       }
+      return returndata;
     }
   }
-}
-
-// src/core/contracts/dependencies/openzeppelin/contracts/IERC20.sol
-
-/**
- * @dev Interface of the ERC20 standard as defined in the EIP.
- */
-interface IERC20 {
-  /**
-   * @dev Returns the amount of tokens in existence.
-   */
-  function totalSupply() external view returns (uint256);
-
-  /**
-   * @dev Returns the amount of tokens owned by `account`.
-   */
-  function balanceOf(address account) external view returns (uint256);
-
-  /**
-   * @dev Moves `amount` tokens from the caller's account to `recipient`.
-   *
-   * Returns a boolean value indicating whether the operation succeeded.
-   *
-   * Emits a {Transfer} event.
-   */
-  function transfer(address recipient, uint256 amount) external returns (bool);
-
-  /**
-   * @dev Returns the remaining number of tokens that `spender` will be
-   * allowed to spend on behalf of `owner` through {transferFrom}. This is
-   * zero by default.
-   *
-   * This value changes when {approve} or {transferFrom} are called.
-   */
-  function allowance(address owner, address spender) external view returns (uint256);
 
   /**
-   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
-   *
-   * Returns a boolean value indicating whether the operation succeeded.
-   *
-   * IMPORTANT: Beware that changing an allowance with this method brings the risk
-   * that someone may use both the old and the new allowance by unfortunate
-   * transaction ordering. One possible solution to mitigate this race
-   * condition is to first reduce the spender's allowance to 0 and set the
-   * desired value afterwards:
-   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
-   *
-   * Emits an {Approval} event.
+   * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the
+   * revert reason or with a default {Errors.FailedCall} error.
    */
-  function approve(address spender, uint256 amount) external returns (bool);
-
-  /**
-   * @dev Moves `amount` tokens from `sender` to `recipient` using the
-   * allowance mechanism. `amount` is then deducted from the caller's
-   * allowance.
-   *
-   * Returns a boolean value indicating whether the operation succeeded.
-   *
-   * Emits a {Transfer} event.
-   */
-  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
-
-  /**
-   * @dev Emitted when `value` tokens are moved from one account (`from`) to
-   * another (`to`).
-   *
-   * Note that `value` may be zero.
-   */
-  event Transfer(address indexed from, address indexed to, uint256 value);
+  function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {
+    if (!success) {
+      _revert(returndata);
+    } else {
+      return returndata;
+    }
+  }
 
   /**
-   * @dev Emitted when the allowance of a `spender` for an `owner` is set by
-   * a call to {approve}. `value` is the new allowance.
+   * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.
    */
-  event Approval(address indexed owner, address indexed spender, uint256 value);
+  function _revert(bytes memory returndata) private pure {
+    // Look for revert reason and bubble it up if present
+    if (returndata.length > 0) {
+      // The easiest way to bubble the revert reason is using memory via assembly
+      assembly ("memory-safe") {
+        let returndata_size := mload(returndata)
+        revert(add(32, returndata), returndata_size)
+      }
+    } else {
+      revert Errors.FailedCall();
+    }
+  }
 }
 
-// src/periphery/contracts/dependencies/openzeppelin/ReentrancyGuard.sol
+// lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol
 
-// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)
+// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)
 
 /**
- * @dev Contract module that helps prevent reentrant calls to a function.
- *
- * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
- * available, which can be applied to functions to make sure there are no nested
- * (reentrant) calls to them.
+ * @dev Provides information about the current execution context, including the
+ * sender of the transaction and its data. While these are generally available
+ * via msg.sender and msg.data, they should not be accessed in such a direct
+ * manner, since when dealing with meta-transactions the account sending and
+ * paying for execution may not be the actual sender (as far as an application
+ * is concerned).
  *
- * Note that because there is a single `nonReentrant` guard, functions marked as
- * `nonReentrant` may not call one another. This can be worked around by making
- * those functions `private`, and then adding `external` `nonReentrant` entry
- * points to them.
- *
- * TIP: If you would like to learn more about reentrancy and alternative ways
- * to protect against it, check out our blog post
- * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
+ * This contract is only required for intermediate, library-like contracts.
  */
-abstract contract ReentrancyGuard {
-  // Booleans are more expensive than uint256 or any type that takes up a full
-  // word because each write operation emits an extra SLOAD to first read the
-  // slot's contents, replace the bits taken up by the boolean, and then write
-  // back. This is the compiler's defense against contract upgrades and
-  // pointer aliasing, and it cannot be disabled.
-
-  // The values being non-zero value makes deployment a bit more expensive,
-  // but in exchange the refund on every call to nonReentrant will be lower in
-  // amount. Since refunds are capped to a percentage of the total
-  // transaction's gas, it is best to keep them low in cases like this one, to
-  // increase the likelihood of the full refund coming into effect.
-  uint256 private constant _NOT_ENTERED = 1;
-  uint256 private constant _ENTERED = 2;
+abstract contract ContextUpgradeable is Initializable {
+  function __Context_init() internal onlyInitializing {}
 
-  uint256 private _status;
+  function __Context_init_unchained() internal onlyInitializing {}
 
-  constructor() {
-    _status = _NOT_ENTERED;
+  function _msgSender() internal view virtual returns (address) {
+    return msg.sender;
   }
 
-  /**
-   * @dev Prevents a contract from calling itself, directly or indirectly.
-   * Calling a `nonReentrant` function from another `nonReentrant`
-   * function is not supported. It is possible to prevent this from happening
-   * by making the `nonReentrant` function external, and making it call a
-   * `private` function that does the actual work.
-   */
-  modifier nonReentrant() {
-    // On the first call to nonReentrant, _notEntered will be true
-    require(_status != _ENTERED, 'ReentrancyGuard: reentrant call');
-
-    // Any calls to nonReentrant after this point will fail
-    _status = _ENTERED;
-
-    _;
-
-    // By storing the original value once again, a refund is triggered (see
-    // https://eips.ethereum.org/EIPS/eip-2200)
-    _status = _NOT_ENTERED;
+  function _msgData() internal view virtual returns (bytes calldata) {
+    return msg.data;
   }
 
-  /**
-   * @dev As we use the guard with the proxy we need to init it with the empty value
-   */
-  function _initGuard() internal {
-    _status = _NOT_ENTERED;
+  function _contextSuffixLength() internal view virtual returns (uint256) {
+    return 0;
   }
 }
 
-// src/core/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol
-
-/**
- * @title VersionedInitializable
- * @author Aave, inspired by the OpenZeppelin Initializable contract
- * @notice Helper contract to implement initializer functions. To use it, replace
- * the constructor with a function that has the `initializer` modifier.
- * @dev WARNING: Unlike constructors, initializer functions must be manually
- * invoked. This applies both to deploying an Initializable contract, as well
- * as extending an Initializable contract via inheritance.
- * WARNING: When used with inheritance, manual care must be taken to not invoke
- * a parent initializer twice, or ensure that all initializers are idempotent,
- * because this is not dealt with automatically as with constructors.
- */
-abstract contract VersionedInitializable {
-  /**
-   * @dev Indicates that the contract has been initialized.
-   */
-  uint256 private lastInitializedRevision = 0;
-
-  /**
-   * @dev Indicates that the contract is in the process of being initialized.
-   */
-  bool private initializing;
-
-  /**
-   * @dev Modifier to use in the initializer function of a contract.
-   */
-  modifier initializer() {
-    uint256 revision = getRevision();
-    require(
-      initializing || isConstructor() || revision > lastInitializedRevision,
-      'Contract instance has already been initialized'
-    );
-
-    bool isTopLevelCall = !initializing;
-    if (isTopLevelCall) {
-      initializing = true;
-      lastInitializedRevision = revision;
-    }
-
-    _;
-
-    if (isTopLevelCall) {
-      initializing = false;
-    }
-  }
-
-  /**
-   * @notice Returns the revision number of the contract
-   * @dev Needs to be defined in the inherited class as a constant.
-   * @return The revision number
-   */
-  function getRevision() internal pure virtual returns (uint256);
-
-  /**
-   * @notice Returns true if and only if the function is running in the constructor
-   * @return True if the function is running in the constructor
-   */
-  function isConstructor() private view returns (bool) {
-    // extcodesize checks the size of the code stored in an address, and
-    // address returns the current address. Since the code is still not
-    // deployed when running a constructor, any checks on its code size will
-    // yield zero, making it an effective way to detect if a contract is
-    // under construction or not.
-    uint256 cs;
-    //solium-disable-next-line
-    assembly {
-      cs := extcodesize(address())
-    }
-    return cs == 0;
-  }
-
-  // Reserved storage space to allow for layout changes in the future.
-  uint256[50] private ______gap;
-}
-
-// src/periphery/contracts/treasury/ICollector.sol
+// lib/aave-v3-origin/src/contracts/treasury/ICollector.sol
 
 interface ICollector {
   struct Stream {
@@ -459,12 +660,63 @@ interface ICollector {
     bool isEntity;
   }
 
-  /** @notice Emitted when the funds admin changes
-   * @param fundsAdmin The new funds admin.
-   **/
-  event NewFundsAdmin(address indexed fundsAdmin);
+  /**
+   * @dev Withdraw amount exceeds available balance
+   */
+  error BalanceExceeded();
 
-  /** @notice Emitted when the new stream is created
+  /**
+   * @dev Deposit smaller than time delta
+   */
+  error DepositSmallerTimeDelta();
+
+  /**
+   * @dev Deposit not multiple of time delta
+   */
+  error DepositNotMultipleTimeDelta();
+
+  /**
+   * @dev Recipient cannot be the contract itself or msg.sender
+   */
+  error InvalidRecipient();
+
+  /**
+   * @dev Start time cannot be before block.timestamp
+   */
+  error InvalidStartTime();
+
+  /**
+   * @dev Stop time must be greater than startTime
+   */
+  error InvalidStopTime();
+
+  /**
+   * @dev Provided address cannot be the zero-address
+   */
+  error InvalidZeroAddress();
+
+  /**
+   * @dev Amount cannot be zero
+   */
+  error InvalidZeroAmount();
+
+  /**
+   * @dev Only caller with FUNDS_ADMIN role can call
+   */
+  error OnlyFundsAdmin();
+
+  /**
+   * @dev Only caller with FUNDS_ADMIN role or stream recipient can call
+   */
+  error OnlyFundsAdminOrRceipient();
+
+  /**
+   * @dev The provided ID does not belong to an existing stream
+   */
+  error StreamDoesNotExist();
+
+  /**
+   * @notice Emitted when the new stream is created
    * @param streamId The identifier of the stream.
    * @param sender The address of the collector.
    * @param recipient The address towards which the money is streamed.
@@ -472,7 +724,8 @@ interface ICollector {
    * @param tokenAddress The ERC20 token to use as streaming currency.
    * @param startTime The unix timestamp for when the stream starts.
    * @param stopTime The unix timestamp for when the stream stops.
-   **/
+   *
+   */
   event CreateStream(
     uint256 indexed streamId,
     address indexed sender,
@@ -507,28 +760,32 @@ interface ICollector {
     uint256 recipientBalance
   );
 
-  /** @notice Returns the mock ETH reference address
+  /**
+   * @notice FUNDS_ADMIN role granted by ACL Manager
+   *
+   */
+  function FUNDS_ADMIN_ROLE() external view returns (bytes32);
+
+  /**
+   * @notice Returns the mock ETH reference address
    * @return address The address
-   **/
+   *
+   */
   function ETH_MOCK_ADDRESS() external pure returns (address);
 
-  /** @notice Initializes the contracts
-   * @param fundsAdmin Funds admin address
-   * @param nextStreamId StreamId to set, applied if greater than 0
-   **/
-  function initialize(address fundsAdmin, uint256 nextStreamId) external;
-
   /**
-   * @notice Return the funds admin, only entity to be able to interact with this contract (controller of reserve)
-   * @return address The address of the funds admin
-   **/
-  function getFundsAdmin() external view returns (address);
+   * @notice Checks if address is funds admin
+   * @return bool If the address has the funds admin role
+   *
+   */
+  function isFundsAdmin(address admin) external view returns (bool);
 
   /**
    * @notice Returns the available funds for the given stream id and address.
    * @param streamId The id of the stream for which to query the balance.
    * @param who The address for which to query the balance.
    * @notice Returns the total funds allocated to `who` as uint256.
+   *
    */
   function balanceOf(uint256 streamId, address who) external view returns (uint256 balance);
 
@@ -537,7 +794,8 @@ interface ICollector {
    * @param token The address of the token to give allowance from
    * @param recipient Allowance's recipient
    * @param amount Allowance to approve
-   **/
+   *
+   */
   function approve(IERC20 token, address recipient, uint256 amount) external;
 
   /**
@@ -545,16 +803,10 @@ interface ICollector {
    * @param token The address of the token to transfer
    * @param recipient Transfer's recipient
    * @param amount Amount to transfer
-   **/
+   *
+   */
   function transfer(IERC20 token, address recipient, uint256 amount) external;
 
-  /**
-   * @dev Transfer the ownership of the funds administrator role.
-          This function should only be callable by the current funds administrator.
-   * @param admin The address of the new funds administrator
-   */
-  function setFundsAdmin(address admin) external;
-
   /**
    * @notice Creates a new stream funded by this contracts itself and paid towards `recipient`.
    * @param recipient The address towards which the money is streamed.
@@ -564,13 +816,9 @@ interface ICollector {
    * @param stopTime The unix timestamp for when the stream stops.
    * @return streamId the uint256 id of the newly created stream.
    */
-  function createStream(
-    address recipient,
-    uint256 deposit,
-    address tokenAddress,
-    uint256 startTime,
-    uint256 stopTime
-  ) external returns (uint256 streamId);
+  function createStream(address recipient, uint256 deposit, address tokenAddress, uint256 startTime, uint256 stopTime)
+    external
+    returns (uint256 streamId);
 
   /**
    * @notice Returns the stream with all its properties.
@@ -578,9 +826,7 @@ interface ICollector {
    * @param streamId The id of the stream to query.
    * @notice Returns the stream object.
    */
-  function getStream(
-    uint256 streamId
-  )
+  function getStream(uint256 streamId)
     external
     view
     returns (
@@ -616,13 +862,468 @@ interface ICollector {
   function getNextStreamId() external view returns (uint256);
 }
 
-// src/core/contracts/dependencies/openzeppelin/contracts/SafeERC20.sol
+// lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol
 
-// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)
+// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)
+
+// lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol
+
+// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)
+
+// lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/contracts/utils/ReentrancyGuardUpgradeable.sol
+
+// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)
+
+/**
+ * @dev Contract module that helps prevent reentrant calls to a function.
+ *
+ * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
+ * available, which can be applied to functions to make sure there are no nested
+ * (reentrant) calls to them.
+ *
+ * Note that because there is a single `nonReentrant` guard, functions marked as
+ * `nonReentrant` may not call one another. This can be worked around by making
+ * those functions `private`, and then adding `external` `nonReentrant` entry
+ * points to them.
+ *
+ * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,
+ * consider using {ReentrancyGuardTransient} instead.
+ *
+ * TIP: If you would like to learn more about reentrancy and alternative ways
+ * to protect against it, check out our blog post
+ * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
+ */
+abstract contract ReentrancyGuardUpgradeable is Initializable {
+  // Booleans are more expensive than uint256 or any type that takes up a full
+  // word because each write operation emits an extra SLOAD to first read the
+  // slot's contents, replace the bits taken up by the boolean, and then write
+  // back. This is the compiler's defense against contract upgrades and
+  // pointer aliasing, and it cannot be disabled.
+
+  // The values being non-zero value makes deployment a bit more expensive,
+  // but in exchange the refund on every call to nonReentrant will be lower in
+  // amount. Since refunds are capped to a percentage of the total
+  // transaction's gas, it is best to keep them low in cases like this one, to
+  // increase the likelihood of the full refund coming into effect.
+  uint256 private constant NOT_ENTERED = 1;
+  uint256 private constant ENTERED = 2;
+
+  /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard
+  struct ReentrancyGuardStorage {
+    uint256 _status;
+  }
+
+  // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))
+  bytes32 private constant ReentrancyGuardStorageLocation =
+    0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;
+
+  function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {
+    assembly {
+      $.slot := ReentrancyGuardStorageLocation
+    }
+  }
+
+  /**
+   * @dev Unauthorized reentrant call.
+   */
+  error ReentrancyGuardReentrantCall();
+
+  function __ReentrancyGuard_init() internal onlyInitializing {
+    __ReentrancyGuard_init_unchained();
+  }
+
+  function __ReentrancyGuard_init_unchained() internal onlyInitializing {
+    ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();
+    $._status = NOT_ENTERED;
+  }
+
+  /**
+   * @dev Prevents a contract from calling itself, directly or indirectly.
+   * Calling a `nonReentrant` function from another `nonReentrant`
+   * function is not supported. It is possible to prevent this from happening
+   * by making the `nonReentrant` function external, and making it call a
+   * `private` function that does the actual work.
+   */
+  modifier nonReentrant() {
+    _nonReentrantBefore();
+    _;
+    _nonReentrantAfter();
+  }
+
+  function _nonReentrantBefore() private {
+    ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();
+    // On the first call to nonReentrant, _status will be NOT_ENTERED
+    if ($._status == ENTERED) {
+      revert ReentrancyGuardReentrantCall();
+    }
+
+    // Any calls to nonReentrant after this point will fail
+    $._status = ENTERED;
+  }
+
+  function _nonReentrantAfter() private {
+    ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();
+    // By storing the original value once again, a refund is triggered (see
+    // https://eips.ethereum.org/EIPS/eip-2200)
+    $._status = NOT_ENTERED;
+  }
+
+  /**
+   * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
+   * `nonReentrant` function in the call stack.
+   */
+  function _reentrancyGuardEntered() internal view returns (bool) {
+    ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();
+    return $._status == ENTERED;
+  }
+}
+
+// lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol
+
+// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)
+
+/**
+ * @dev Implementation of the {IERC165} interface.
+ *
+ * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check
+ * for the additional interface id that will be supported. For example:
+ *
+ * ```solidity
+ * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
+ *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
+ * }
+ * ```
+ */
+abstract contract ERC165Upgradeable is Initializable, IERC165 {
+  function __ERC165_init() internal onlyInitializing {}
+
+  function __ERC165_init_unchained() internal onlyInitializing {}
+  /**
+   * @dev See {IERC165-supportsInterface}.
+   */
+
+  function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
+    return interfaceId == type(IERC165).interfaceId;
+  }
+}
+
+// lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol
+
+// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)
+
+/**
+ * @title IERC1363
+ * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].
+ *
+ * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract
+ * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.
+ */
+interface IERC1363 is IERC20, IERC165 {
+  /*
+     * Note: the ERC-165 identifier for this interface is 0xb0202a11.
+     * 0xb0202a11 ===
+     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^
+     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^
+     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^
+     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^
+     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^
+     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))
+     */
+
+  /**
+   * @dev Moves a `value` amount of tokens from the caller's account to `to`
+   * and then calls {IERC1363Receiver-onTransferReceived} on `to`.
+   * @param to The address which you want to transfer to.
+   * @param value The amount of tokens to be transferred.
+   * @return A boolean value indicating whether the operation succeeded unless throwing.
+   */
+  function transferAndCall(address to, uint256 value) external returns (bool);
+
+  /**
+   * @dev Moves a `value` amount of tokens from the caller's account to `to`
+   * and then calls {IERC1363Receiver-onTransferReceived} on `to`.
+   * @param to The address which you want to transfer to.
+   * @param value The amount of tokens to be transferred.
+   * @param data Additional data with no specified format, sent in call to `to`.
+   * @return A boolean value indicating whether the operation succeeded unless throwing.
+   */
+  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);
+
+  /**
+   * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism
+   * and then calls {IERC1363Receiver-onTransferReceived} on `to`.
+   * @param from The address which you want to send tokens from.
+   * @param to The address which you want to transfer to.
+   * @param value The amount of tokens to be transferred.
+   * @return A boolean value indicating whether the operation succeeded unless throwing.
+   */
+  function transferFromAndCall(address from, address to, uint256 value) external returns (bool);
+
+  /**
+   * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism
+   * and then calls {IERC1363Receiver-onTransferReceived} on `to`.
+   * @param from The address which you want to send tokens from.
+   * @param to The address which you want to transfer to.
+   * @param value The amount of tokens to be transferred.
+   * @param data Additional data with no specified format, sent in call to `to`.
+   * @return A boolean value indicating whether the operation succeeded unless throwing.
+   */
+  function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);
+
+  /**
+   * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
+   * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.
+   * @param spender The address which will spend the funds.
+   * @param value The amount of tokens to be spent.
+   * @return A boolean value indicating whether the operation succeeded unless throwing.
+   */
+  function approveAndCall(address spender, uint256 value) external returns (bool);
+
+  /**
+   * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
+   * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.
+   * @param spender The address which will spend the funds.
+   * @param value The amount of tokens to be spent.
+   * @param data Additional data with no specified format, sent in call to `spender`.
+   * @return A boolean value indicating whether the operation succeeded unless throwing.
+   */
+  function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);
+}
+
+// lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol
+
+// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)
+
+/**
+ * @dev Contract module that allows children to implement role-based access
+ * control mechanisms. This is a lightweight version that doesn't allow enumerating role
+ * members except through off-chain means by accessing the contract event logs. Some
+ * applications may benefit from on-chain enumerability, for those cases see
+ * {AccessControlEnumerable}.
+ *
+ * Roles are referred to by their `bytes32` identifier. These should be exposed
+ * in the external API and be unique. The best way to achieve this is by
+ * using `public constant` hash digests:
+ *
+ * ```solidity
+ * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
+ * ```
+ *
+ * Roles can be used to represent a set of permissions. To restrict access to a
+ * function call, use {hasRole}:
+ *
+ * ```solidity
+ * function foo() public {
+ *     require(hasRole(MY_ROLE, msg.sender));
+ *     ...
+ * }
+ * ```
+ *
+ * Roles can be granted and revoked dynamically via the {grantRole} and
+ * {revokeRole} functions. Each role has an associated admin role, and only
+ * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
+ *
+ * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
+ * that only accounts with this role will be able to grant or revoke other
+ * roles. More complex role relationships can be created by using
+ * {_setRoleAdmin}.
+ *
+ * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
+ * grant and revoke this role. Extra precautions should be taken to secure
+ * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}
+ * to enforce additional security measures for this role.
+ */
+abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {
+  struct RoleData {
+    mapping(address account => bool) hasRole;
+    bytes32 adminRole;
+  }
+
+  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
+
+  /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl
+  struct AccessControlStorage {
+    mapping(bytes32 role => RoleData) _roles;
+  }
+
+  // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))
+  bytes32 private constant AccessControlStorageLocation =
+    0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;
+
+  function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {
+    assembly {
+      $.slot := AccessControlStorageLocation
+    }
+  }
+
+  /**
+   * @dev Modifier that checks that an account has a specific role. Reverts
+   * with an {AccessControlUnauthorizedAccount} error including the required role.
+   */
+  modifier onlyRole(bytes32 role) {
+    _checkRole(role);
+    _;
+  }
+
+  function __AccessControl_init() internal onlyInitializing {}
+
+  function __AccessControl_init_unchained() internal onlyInitializing {}
+  /**
+   * @dev See {IERC165-supportsInterface}.
+   */
+
+  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
+    return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
+  }
+
+  /**
+   * @dev Returns `true` if `account` has been granted `role`.
+   */
+  function hasRole(bytes32 role, address account) public view virtual returns (bool) {
+    AccessControlStorage storage $ = _getAccessControlStorage();
+    return $._roles[role].hasRole[account];
+  }
+
+  /**
+   * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`
+   * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.
+   */
+  function _checkRole(bytes32 role) internal view virtual {
+    _checkRole(role, _msgSender());
+  }
+
+  /**
+   * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`
+   * is missing `role`.
+   */
+  function _checkRole(bytes32 role, address account) internal view virtual {
+    if (!hasRole(role, account)) {
+      revert AccessControlUnauthorizedAccount(account, role);
+    }
+  }
+
+  /**
+   * @dev Returns the admin role that controls `role`. See {grantRole} and
+   * {revokeRole}.
+   *
+   * To change a role's admin, use {_setRoleAdmin}.
+   */
+  function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {
+    AccessControlStorage storage $ = _getAccessControlStorage();
+    return $._roles[role].adminRole;
+  }
+
+  /**
+   * @dev Grants `role` to `account`.
+   *
+   * If `account` had not been already granted `role`, emits a {RoleGranted}
+   * event.
+   *
+   * Requirements:
+   *
+   * - the caller must have ``role``'s admin role.
+   *
+   * May emit a {RoleGranted} event.
+   */
+  function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
+    _grantRole(role, account);
+  }
+
+  /**
+   * @dev Revokes `role` from `account`.
+   *
+   * If `account` had been granted `role`, emits a {RoleRevoked} event.
+   *
+   * Requirements:
+   *
+   * - the caller must have ``role``'s admin role.
+   *
+   * May emit a {RoleRevoked} event.
+   */
+  function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
+    _revokeRole(role, account);
+  }
+
+  /**
+   * @dev Revokes `role` from the calling account.
+   *
+   * Roles are often managed via {grantRole} and {revokeRole}: this function's
+   * purpose is to provide a mechanism for accounts to lose their privileges
+   * if they are compromised (such as when a trusted device is misplaced).
+   *
+   * If the calling account had been revoked `role`, emits a {RoleRevoked}
+   * event.
+   *
+   * Requirements:
+   *
+   * - the caller must be `callerConfirmation`.
+   *
+   * May emit a {RoleRevoked} event.
+   */
+  function renounceRole(bytes32 role, address callerConfirmation) public virtual {
+    if (callerConfirmation != _msgSender()) {
+      revert AccessControlBadConfirmation();
+    }
+
+    _revokeRole(role, callerConfirmation);
+  }
+
+  /**
+   * @dev Sets `adminRole` as ``role``'s admin role.
+   *
+   * Emits a {RoleAdminChanged} event.
+   */
+  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
+    AccessControlStorage storage $ = _getAccessControlStorage();
+    bytes32 previousAdminRole = getRoleAdmin(role);
+    $._roles[role].adminRole = adminRole;
+    emit RoleAdminChanged(role, previousAdminRole, adminRole);
+  }
+
+  /**
+   * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.
+   *
+   * Internal function without access restriction.
+   *
+   * May emit a {RoleGranted} event.
+   */
+  function _grantRole(bytes32 role, address account) internal virtual returns (bool) {
+    AccessControlStorage storage $ = _getAccessControlStorage();
+    if (!hasRole(role, account)) {
+      $._roles[role].hasRole[account] = true;
+      emit RoleGranted(role, account, _msgSender());
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  /**
+   * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.
+   *
+   * Internal function without access restriction.
+   *
+   * May emit a {RoleRevoked} event.
+   */
+  function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {
+    AccessControlStorage storage $ = _getAccessControlStorage();
+    if (hasRole(role, account)) {
+      $._roles[role].hasRole[account] = false;
+      emit RoleRevoked(role, account, _msgSender());
+      return true;
+    } else {
+      return false;
+    }
+  }
+}
+
+// lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol
+
+// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/utils/SafeERC20.sol)
 
 /**
  * @title SafeERC20
- * @dev Wrappers around ERC20 operations that throw on failure (when the token
+ * @dev Wrappers around ERC-20 operations that throw on failure (when the token
  * contract returns false). Tokens that return no value (and instead revert or
  * throw on failure) are also supported, non-reverting calls are assumed to be
  * successful.
@@ -630,54 +1331,131 @@ interface ICollector {
  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  */
 library SafeERC20 {
-  using Address for address;
+  /**
+   * @dev An operation with an ERC-20 token failed.
+   */
+  error SafeERC20FailedOperation(address token);
 
+  /**
+   * @dev Indicates a failed `decreaseAllowance` request.
+   */
+  error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);
+
+  /**
+   * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
+   * non-reverting calls are assumed to be successful.
+   */
   function safeTransfer(IERC20 token, address to, uint256 value) internal {
-    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
+    _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));
   }
 
+  /**
+   * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
+   * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
+   */
   function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
-    _callOptionalReturn(
-      token,
-      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)
-    );
+    _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));
   }
 
   /**
-   * @dev Deprecated. This function has issues similar to the ones found in
-   * {IERC20-approve}, and its usage is discouraged.
+   * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
+   * non-reverting calls are assumed to be successful.
    *
-   * Whenever possible, use {safeIncreaseAllowance} and
-   * {safeDecreaseAllowance} instead.
+   * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the "client"
+   * smart contract uses ERC-7674 to set temporary allowances, then the "client" smart contract should avoid using
+   * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract
+   * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.
    */
-  function safeApprove(IERC20 token, address spender, uint256 value) internal {
-    // safeApprove should only be called when setting an initial allowance,
-    // or when resetting it to zero. To increase and decrease it, use
-    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
-    require(
-      (value == 0) || (token.allowance(address(this), spender) == 0),
-      'SafeERC20: approve from non-zero to non-zero allowance'
-    );
-    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
-  }
-
   function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
-    uint256 newAllowance = token.allowance(address(this), spender) + value;
-    _callOptionalReturn(
-      token,
-      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)
-    );
+    uint256 oldAllowance = token.allowance(address(this), spender);
+    forceApprove(token, spender, oldAllowance + value);
   }
 
-  function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
+  /**
+   * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no
+   * value, non-reverting calls are assumed to be successful.
+   *
+   * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the "client"
+   * smart contract uses ERC-7674 to set temporary allowances, then the "client" smart contract should avoid using
+   * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract
+   * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.
+   */
+  function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {
     unchecked {
-      uint256 oldAllowance = token.allowance(address(this), spender);
-      require(oldAllowance >= value, 'SafeERC20: decreased allowance below zero');
-      uint256 newAllowance = oldAllowance - value;
-      _callOptionalReturn(
-        token,
-        abi.encodeWithSelector(token.approve.selector, spender, newAllowance)
-      );
+      uint256 currentAllowance = token.allowance(address(this), spender);
+      if (currentAllowance < requestedDecrease) {
+        revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);
+      }
+      forceApprove(token, spender, currentAllowance - requestedDecrease);
+    }
+  }
+
+  /**
+   * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
+   * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
+   * to be set to zero before setting it to a non-zero value, such as USDT.
+   *
+   * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function
+   * only sets the "standard" allowance. Any temporary allowance will remain active, in addition to the value being
+   * set here.
+   */
+  function forceApprove(IERC20 token, address spender, uint256 value) internal {
+    bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));
+
+    if (!_callOptionalReturnBool(token, approvalCall)) {
+      _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));
+      _callOptionalReturn(token, approvalCall);
+    }
+  }
+
+  /**
+   * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no
+   * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when
+   * targeting contracts.
+   *
+   * Reverts if the returned value is other than `true`.
+   */
+  function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {
+    if (to.code.length == 0) {
+      safeTransfer(token, to, value);
+    } else if (!token.transferAndCall(to, value, data)) {
+      revert SafeERC20FailedOperation(address(token));
+    }
+  }
+
+  /**
+   * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target
+   * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when
+   * targeting contracts.
+   *
+   * Reverts if the returned value is other than `true`.
+   */
+  function transferFromAndCallRelaxed(IERC1363 token, address from, address to, uint256 value, bytes memory data)
+    internal
+  {
+    if (to.code.length == 0) {
+      safeTransferFrom(token, from, to, value);
+    } else if (!token.transferFromAndCall(from, to, value, data)) {
+      revert SafeERC20FailedOperation(address(token));
+    }
+  }
+
+  /**
+   * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no
+   * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when
+   * targeting contracts.
+   *
+   * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.
+   * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}
+   * once without retrying, and relies on the returned value to be true.
+   *
+   * Reverts if the returned value is other than `true`.
+   */
+  function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {
+    if (to.code.length == 0) {
+      forceApprove(token, to, value);
+    } else if (!token.approveAndCall(to, value, data)) {
+      revert SafeERC20FailedOperation(address(token));
     }
   }
 
@@ -686,21 +1464,51 @@ library SafeERC20 {
    * on the return value: the return value is optional (but if data is returned, it must not be false).
    * @param token The token targeted by the call.
    * @param data The call data (encoded using abi.encode or one of its variants).
+   *
+   * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.
    */
   function _callOptionalReturn(IERC20 token, bytes memory data) private {
-    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
-    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
-    // the target address contains contract code and also asserts for success in the low-level call.
+    uint256 returnSize;
+    uint256 returnValue;
+    assembly ("memory-safe") {
+      let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)
+      // bubble errors
+      if iszero(success) {
+        let ptr := mload(0x40)
+        returndatacopy(ptr, 0, returndatasize())
+        revert(ptr, returndatasize())
+      }
+      returnSize := returndatasize()
+      returnValue := mload(0)
+    }
+
+    if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {
+      revert SafeERC20FailedOperation(address(token));
+    }
+  }
 
-    bytes memory returndata = address(token).functionCall(data, 'SafeERC20: low-level call failed');
-    if (returndata.length > 0) {
-      // Return data is optional
-      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');
+  /**
+   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
+   * on the return value: the return value is optional (but if data is returned, it must not be false).
+   * @param token The token targeted by the call.
+   * @param data The call data (encoded using abi.encode or one of its variants).
+   *
+   * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.
+   */
+  function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
+    bool success;
+    uint256 returnSize;
+    uint256 returnValue;
+    assembly ("memory-safe") {
+      success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)
+      returnSize := returndatasize()
+      returnValue := mload(0)
     }
+    return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);
   }
 }
 
-// src/periphery/contracts/treasury/Collector.sol
+// lib/aave-v3-origin/src/contracts/treasury/Collector.sol
 
 /**
  * @title Collector
@@ -714,22 +1522,29 @@ library SafeERC20 {
  * - Adapted codebase to Solidity 0.8.11, mainly removing SafeMath and CarefulMath to use native safe math
  * - Same as with creation, on Sablier the `sender` and `recipient` can cancel a stream. Here, only fund admin and recipient
  * @author BGD Labs
- **/
-contract Collector is VersionedInitializable, ICollector, ReentrancyGuard {
+ *
+ */
+contract Collector is AccessControlUpgradeable, ReentrancyGuardUpgradeable, ICollector {
   using SafeERC20 for IERC20;
   using Address for address payable;
 
-  /*** Storage Properties ***/
-
   /**
-   * @notice Address of the current funds admin.
+   * Storage Properties **
    */
-  address internal _fundsAdmin;
+  /// @inheritdoc ICollector
+  address public constant ETH_MOCK_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
 
-  /**
-   * @notice Current revision of the contract.
-   */
-  uint256 public constant REVISION = 5;
+  /// @inheritdoc ICollector
+  bytes32 public constant FUNDS_ADMIN_ROLE = 'FUNDS_ADMIN';
+
+  // Reserved storage space to account for deprecated inherited storage
+  // 0 was lastInitializedRevision
+  // 1-50 were the ____gap
+  // 51 was the reentrancy guard _status
+  // 52 was the _fundsAdmin
+  // On some networks the layout was shifted by 1 due to `initializing` being on slot 1
+  // The upgrade proposal would in this case manually shift the storage layout to properly align the networks
+  uint256[53] private ______gap;
 
   /**
    * @notice Counter for new stream ids.
@@ -741,16 +1556,17 @@ contract Collector is VersionedInitializable, ICollector, ReentrancyGuard {
    */
   mapping(uint256 => Stream) private _streams;
 
-  /// @inheritdoc ICollector
-  address public constant ETH_MOCK_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
-
-  /*** Modifiers ***/
+  /**
+   * Modifiers **
+   */
 
   /**
-   * @dev Throws if the caller is not the funds admin.
+   * @dev Throws if the caller does not have the FUNDS_ADMIN role
    */
   modifier onlyFundsAdmin() {
-    require(msg.sender == _fundsAdmin, 'ONLY_BY_FUNDS_ADMIN');
+    if (_onlyFundsAdmin() == false) {
+      revert OnlyFundsAdmin();
+    }
     _;
   }
 
@@ -759,10 +1575,9 @@ contract Collector is VersionedInitializable, ICollector, ReentrancyGuard {
    * @param streamId The id of the stream to query.
    */
   modifier onlyAdminOrRecipient(uint256 streamId) {
-    require(
-      msg.sender == _fundsAdmin || msg.sender == _streams[streamId].recipient,
-      'caller is not the funds admin or the recipient of the stream'
-    );
+    if (_onlyFundsAdmin() == false && msg.sender != _streams[streamId].recipient) {
+      revert OnlyFundsAdminOrRceipient();
+    }
     _;
   }
 
@@ -770,31 +1585,39 @@ contract Collector is VersionedInitializable, ICollector, ReentrancyGuard {
    * @dev Throws if the provided id does not point to a valid stream.
    */
   modifier streamExists(uint256 streamId) {
-    require(_streams[streamId].isEntity, 'stream does not exist');
+    if (!_streams[streamId].isEntity) revert StreamDoesNotExist();
     _;
   }
 
-  /*** Contract Logic Starts Here */
+  constructor() {
+    _disableInitializers();
+  }
 
-  /// @inheritdoc ICollector
-  function initialize(address fundsAdmin, uint256 nextStreamId) external initializer {
+  /**
+   * Contract Logic Starts Here
+   */
+
+  /**
+   * @notice Initializes the contracts
+   * @param nextStreamId StreamId to set, applied if greater than 0
+   * @param admin The default admin managing the FundsAdmins
+   *
+   */
+  function initialize(uint256 nextStreamId, address admin) external virtual initializer {
+    __AccessControl_init();
+    __ReentrancyGuard_init();
+    _grantRole(DEFAULT_ADMIN_ROLE, admin);
     if (nextStreamId != 0) {
       _nextStreamId = nextStreamId;
     }
-
-    _setFundsAdmin(fundsAdmin);
-  }
-
-  /*** View Functions ***/
-
-  /// @inheritdoc VersionedInitializable
-  function getRevision() internal pure override returns (uint256) {
-    return REVISION;
   }
 
+  /**
+   * View Functions **
+   */
   /// @inheritdoc ICollector
-  function getFundsAdmin() external view returns (address) {
-    return _fundsAdmin;
+  function isFundsAdmin(address admin) external view returns (bool) {
+    return hasRole(FUNDS_ADMIN_ROLE, admin);
   }
 
   /// @inheritdoc ICollector
@@ -803,9 +1626,7 @@ contract Collector is VersionedInitializable, ICollector, ReentrancyGuard {
   }
 
   /// @inheritdoc ICollector
-  function getStream(
-    uint256 streamId
-  )
+  function getStream(uint256 streamId)
     external
     view
     streamExists(streamId)
@@ -852,10 +1673,7 @@ contract Collector is VersionedInitializable, ICollector, ReentrancyGuard {
   }
 
   /// @inheritdoc ICollector
-  function balanceOf(
-    uint256 streamId,
-    address who
-  ) public view streamExists(streamId) returns (uint256 balance) {
+  function balanceOf(uint256 streamId, address who) public view streamExists(streamId) returns (uint256 balance) {
     Stream memory stream = _streams[streamId];
     BalanceOfLocalVars memory vars;
 
@@ -880,16 +1698,18 @@ contract Collector is VersionedInitializable, ICollector, ReentrancyGuard {
     return 0;
   }
 
-  /*** Public Effects & Interactions Functions ***/
+  /**
+   * Public Effects & Interactions Functions **
+   */
 
   /// @inheritdoc ICollector
   function approve(IERC20 token, address recipient, uint256 amount) external onlyFundsAdmin {
-    token.safeApprove(recipient, amount);
+    token.forceApprove(recipient, amount);
   }
 
   /// @inheritdoc ICollector
   function transfer(IERC20 token, address recipient, uint256 amount) external onlyFundsAdmin {
-    require(recipient != address(0), 'INVALID_0X_RECIPIENT');
+    if (recipient == address(0)) revert InvalidZeroAddress();
 
     if (address(token) == ETH_MOCK_ADDRESS) {
       payable(recipient).sendValue(amount);
@@ -898,18 +1718,8 @@ contract Collector is VersionedInitializable, ICollector, ReentrancyGuard {
     }
   }
 
-  /// @inheritdoc ICollector
-  function setFundsAdmin(address admin) external onlyFundsAdmin {
-    _setFundsAdmin(admin);
-  }
-
-  /**
-   * @dev Transfer the ownership of the funds administrator role.
-   * @param admin The address of the new funds administrator
-   */
-  function _setFundsAdmin(address admin) internal {
-    _fundsAdmin = admin;
-    emit NewFundsAdmin(admin);
+  function _onlyFundsAdmin() internal view returns (bool) {
+    return hasRole(FUNDS_ADMIN_ROLE, msg.sender);
   }
 
   struct CreateStreamLocalVars {
@@ -931,28 +1741,26 @@ contract Collector is VersionedInitializable, ICollector, ReentrancyGuard {
    *  Throws if the contract is not allowed to transfer enough tokens.
    *  Throws if there is a token transfer failure.
    */
-  function createStream(
-    address recipient,
-    uint256 deposit,
-    address tokenAddress,
-    uint256 startTime,
-    uint256 stopTime
-  ) external onlyFundsAdmin returns (uint256) {
-    require(recipient != address(0), 'stream to the zero address');
-    require(recipient != address(this), 'stream to the contract itself');
-    require(recipient != msg.sender, 'stream to the caller');
-    require(deposit > 0, 'deposit is zero');
-    require(startTime >= block.timestamp, 'start time before block.timestamp');
-    require(stopTime > startTime, 'stop time before the start time');
+  function createStream(address recipient, uint256 deposit, address tokenAddress, uint256 startTime, uint256 stopTime)
+    external
+    onlyFundsAdmin
+    returns (uint256)
+  {
+    if (recipient == address(0)) revert InvalidZeroAddress();
+    if (recipient == address(this)) revert InvalidRecipient();
+    if (recipient == msg.sender) revert InvalidRecipient();
+    if (deposit == 0) revert InvalidZeroAmount();
+    if (startTime < block.timestamp) revert InvalidStartTime();
+    if (stopTime <= startTime) revert InvalidStopTime();
 
     CreateStreamLocalVars memory vars;
     vars.duration = stopTime - startTime;
 
     /* Without this, the rate per second would be zero. */
-    require(deposit >= vars.duration, 'deposit smaller than time delta');
+    if (deposit < vars.duration) revert DepositSmallerTimeDelta();
 
     /* This condition avoids dealing with remainders */
-    require(deposit % vars.duration == 0, 'deposit not multiple of time delta');
+    if (deposit % vars.duration > 0) revert DepositNotMultipleTimeDelta();
 
     vars.ratePerSecond = deposit / vars.duration;
 
@@ -973,15 +1781,7 @@ contract Collector is VersionedInitializable, ICollector, ReentrancyGuard {
     /* Increment the next stream id. */
     _nextStreamId++;
 
-    emit CreateStream(
-      streamId,
-      address(this),
-      recipient,
-      deposit,
-      tokenAddress,
-      startTime,
-      stopTime
-    );
+    emit CreateStream(streamId, address(this), recipient, deposit, tokenAddress, startTime, stopTime);
     return streamId;
   }
 
@@ -992,15 +1792,18 @@ contract Collector is VersionedInitializable, ICollector, ReentrancyGuard {
    *  Throws if the amount exceeds the available balance.
    *  Throws if there is a token transfer failure.
    */
-  function withdrawFromStream(
-    uint256 streamId,
-    uint256 amount
-  ) external nonReentrant streamExists(streamId) onlyAdminOrRecipient(streamId) returns (bool) {
-    require(amount > 0, 'amount is zero');
+  function withdrawFromStream(uint256 streamId, uint256 amount)
+    external
+    nonReentrant
+    streamExists(streamId)
+    onlyAdminOrRecipient(streamId)
+    returns (bool)
+  {
+    if (amount == 0) revert InvalidZeroAmount();
     Stream memory stream = _streams[streamId];
 
     uint256 balance = balanceOf(streamId, stream.recipient);
-    require(balance >= amount, 'amount exceeds the available balance');
+    if (balance < amount) revert BalanceExceeded();
 
     _streams[streamId].remainingBalance = stream.remainingBalance - amount;
 
@@ -1017,9 +1820,13 @@ contract Collector is VersionedInitializable, ICollector, ReentrancyGuard {
    *  Throws if the caller is not the funds admin or the recipient of the stream.
    *  Throws if there is a token transfer failure.
    */
-  function cancelStream(
-    uint256 streamId
-  ) external nonReentrant streamExists(streamId) onlyAdminOrRecipient(streamId) returns (bool) {
+  function cancelStream(uint256 streamId)
+    external
+    nonReentrant
+    streamExists(streamId)
+    onlyAdminOrRecipient(streamId)
+    returns (bool)
+  {
     Stream memory stream = _streams[streamId];
     uint256 senderBalance = balanceOf(streamId, stream.sender);
     uint256 recipientBalance = balanceOf(streamId, stream.recipient);
@@ -1032,4 +1839,32 @@ contract Collector is VersionedInitializable, ICollector, ReentrancyGuard {
     emit CancelStream(streamId, stream.sender, stream.recipient, senderBalance, recipientBalance);
     return true;
   }
+
+  /// @dev needed in order to receive ETH from the Aave v1 ecosystem reserve
+  receive() external payable {}
+}
+
+// src/CollectorWithCustomImpl.sol
+
+/**
+ * @title Collector
+ * Custom modifications of this implementation:
+ * - the initialize function manually alters private storage slots via assembly
+ * - storage slot 0 (previously revision) is reset to zero
+ * - storage slot 51 (previously _status) is set to zero
+ * - storage slot 52 (previously _fundsAdmin) is set to zero
+ * @author BGD Labs
+ *
+ */
+contract CollectorWithCustomImpl is Collector {
+  function initialize(uint256, address admin) external virtual override initializer {
+    assembly {
+      sstore(0, 0) // this slot was revision, which is no longer used
+      sstore(51, 0) // this slot was _status, but is now part of the gap
+      sstore(52, 0) // this slot was _fundsAdmin, but is now unused
+    }
+    __AccessControl_init();
+    __ReentrancyGuard_init();
+    _grantRole(DEFAULT_ADMIN_ROLE, admin);
+  }
 }
